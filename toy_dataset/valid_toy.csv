diff,msg,repo,sha,time
"new file mode 100644 <nl> index 0000000000 . . 845443d99b <nl> mmm / dev / null <nl> ppp b / examples / paddle / sentiment_bilstm / __main__ . py <nl> <nl> + def write_parameter ( outfile , feats ) : <nl> + "" "" "" <nl> + From https : / / github . com / baidu / Paddle / issues / 490 <nl> + <nl> + outfile : Output file name with string type . * * Note * * , it should be the same as it in the above config . <nl> + feats : Parameter with float type . <nl> + "" "" "" <nl> + version = 0 <nl> + value_size = 4 ; # means float type <nl> + ret = b "" "" <nl> + for feat in feats : <nl> + ret + = feat . tostring ( ) <nl> + size = len ( ret ) / 4 <nl> + fo = open ( outfile , ' wb ' ) <nl> + fo . write ( struct . pack ( ' iIQ ' , version , value_size , size ) ) <nl> + fo . write ( ret ) <nl> + <nl> + <nl> + # config = trainer_config . py <nl> + # output = . / model_output <nl> + # paddle train - - config = $ config \ <nl> + # - - save_dir = $ output \ <nl> + # - - job = train \ <nl> + # - - use_gpu = false \ <nl> + # - - trainer_count = 4 \ <nl> + # - - num_passes = 10 \ <nl> + # - - log_period = 20 \ <nl> + # - - dot_period = 20 \ <nl> + # - - show_parameter_stats_period = 100 \ <nl> + # - - test_all_data_in_one_period = 1 \ <nl> + # 2 > & 1 | tee ' train . log ' <nl> new file mode 100644 <nl> index 0000000000 . . cdee7cdf96 <nl> mmm / dev / null <nl> ppp b / examples / paddle / sentiment_bilstm / config . py <nl> <nl> + from paddle . trainer . PyDataProvider2 import * <nl> + <nl> + <nl> + def get_features ( doc ) : <nl> + return numpy . asarray ( <nl> + [ t . rank + 1 for t in doc <nl> + if t . has_vector and not t . is_punct and not t . is_space ] , <nl> + dtype = ' int32 ' ) <nl> + <nl> + <nl> + def on_init ( settings , lang_name , * * kwargs ) : <nl> + print ( "" Loading spaCy "" ) <nl> + nlp = spacy . load ( ' en ' , entity = False ) <nl> + vectors = get_vectors ( nlp ) <nl> + settings . input_types = [ <nl> + # The text is a sequence of integer values , and each value is a word id . <nl> + # The whole sequence is the sentences that we want to predict its <nl> + # sentimental . <nl> + integer_value ( vectors . shape [ 0 ] , seq_type = SequenceType ) , # text input <nl> + <nl> + # label positive / negative <nl> + integer_value ( 2 ) <nl> + ] <nl> + settings . nlp = nlp <nl> + settings . vectors = vectors <nl> + <nl> + <nl> + @ provider ( init_hook = on_init ) <nl> + def process ( settings , data_dir ) : # settings is not used currently . <nl> + texts , labels = read_data ( data_dir ) <nl> + for doc , label in zip ( nlp . pipe ( train_texts , batch_size = 5000 , n_threads = 3 ) , <nl> + labels ) : <nl> + for sent in doc . sents : <nl> + ids = get_features ( sent ) <nl> + # give data to paddle . <nl> + yield ids , label <nl> new file mode 100644 <nl> index 0000000000 . . 84e9732c0b <nl> mmm / dev / null <nl> ppp b / examples / paddle / sentiment_bilstm / networks . py <nl> <nl> + from paddle . trainer_config_helpers import * <nl> + <nl> + <nl> + def bidirectional_lstm_net ( input_dim , <nl> + class_dim = 2 , <nl> + emb_dim = 128 , <nl> + lstm_dim = 128 , <nl> + is_predict = False ) : <nl> + data = data_layer ( "" word "" , input_dim ) <nl> + emb = embedding_layer ( input = data , size = emb_dim ) <nl> + bi_lstm = bidirectional_lstm ( input = emb , size = lstm_dim ) <nl> + dropout = dropout_layer ( input = bi_lstm , dropout_rate = 0 . 5 ) <nl> + output = fc_layer ( input = dropout , size = class_dim , act = SoftmaxActivation ( ) ) <nl> + <nl> + if not is_predict : <nl> + lbl = data_layer ( "" label "" , 1 ) <nl> + outputs ( classification_cost ( input = output , label = lbl ) ) <nl> + else : <nl> + outputs ( output ) <nl>",Add paddle sentiment example,explosion/spaCy,409a18bd4251a219842b6a15eb30ce9039eda431,2016-11-20T02:35:23Z
mmm a / Doc / library / xml . rst <nl> ppp b / Doc / library / xml . rst <nl> circumvent firewalls . <nl> The following table gives an overview of the known attacks and whether <nl> the various modules are vulnerable to them . <nl> <nl> - = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = <nl> - kind sax etree minidom pulldom xmlrpc <nl> - = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = <nl> - billion laughs * * Yes * * * * Yes * * * * Yes * * * * Yes * * * * Yes * * <nl> - quadratic blowup * * Yes * * * * Yes * * * * Yes * * * * Yes * * * * Yes * * <nl> - external entity expansion * * Yes * * No ( 1 ) No ( 2 ) * * Yes * * No ( 3 ) <nl> - ` DTD ` _ retrieval * * Yes * * No No * * Yes * * No <nl> - decompression bomb No No No No * * Yes * * <nl> - = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = <nl> + = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = <nl> + kind sax etree minidom pulldom xmlrpc <nl> + = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = <nl> + billion laughs * * Vulnerable * * * * Vulnerable * * * * Vulnerable * * * * Vulnerable * * * * Vulnerable * * <nl> + quadratic blowup * * Vulnerable * * * * Vulnerable * * * * Vulnerable * * * * Vulnerable * * * * Vulnerable * * <nl> + external entity expansion * * Vulnerable * * Safe ( 1 ) Safe ( 2 ) * * Vulnerable * * Safe ( 3 ) <nl> + ` DTD ` _ retrieval * * Vulnerable * * Safe Safe * * Vulnerable * * Safe <nl> + decompression bomb Safe Safe Safe Safe * * Vulnerable * * <nl> + = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = <nl> <nl> 1 . : mod : ` xml . etree . ElementTree ` doesn ' t expand external entities and raises a <nl> : exc : ` ParserError ` when an entity occurs . <nl>,Issue : Update XML vulnerability table to use Safe / Vulnerable instead of No / Yes . ( 3 . 6 - > 3 . 7 ),python/cpython,174d79a28453f9fb60e7cdec793032934622ec24,2016-10-13T21:32:55Z
"new file mode 100644 <nl> index 0000000000000 . . 4814131fd49ba <nl> mmm / dev / null <nl> ppp b / lib / ansible / modules / storage / purestorage / purefa_offload . py <nl> <nl> + # ! / usr / bin / python <nl> + # - * - coding : utf - 8 - * - <nl> + <nl> + # ( c ) 2019 , Simon Dodsley ( simon @ purestorage . com ) <nl> + # GNU General Public License v3 . 0 + ( see COPYING or https : / / www . gnu . org / licenses / gpl - 3 . 0 . txt ) <nl> + <nl> + from __future__ import absolute_import , division , print_function <nl> + __metaclass__ = type <nl> + <nl> + ANSIBLE_METADATA = { ' metadata_version ' : ' 1 . 1 ' , <nl> + ' status ' : [ ' preview ' ] , <nl> + ' supported_by ' : ' community ' } <nl> + <nl> + DOCUMENTATION = r ' ' ' <nl> + mmm <nl> + module : purefa_offload <nl> + version_added : ' 2 . 8 ' <nl> + short_description : Create , modify and delete NFS or S3 offload targets <nl> + description : <nl> + - Create , modify and delete NFS or S3 offload targets . <nl> + - Only supported on Purity v5 . 2 . 0 or higher . <nl> + - You must have a correctly configured offload network for offload to work . <nl> + author : <nl> + - Pure Storage Ansible Team ( @ sdodsley ) < pure - ansible - team @ purestorage . com > <nl> + options : <nl> + state : <nl> + description : <nl> + - Define state of offload <nl> + default : present <nl> + choices : [ absent , present ] <nl> + type : str <nl> + name : <nl> + description : <nl> + - The name of the offload target <nl> + required : true <nl> + type : str <nl> + protocol : <nl> + description : <nl> + - Define which protocol the offload engine uses <nl> + default : nfs <nl> + choices : [ nfs , s3 ] <nl> + type : str <nl> + address : <nl> + description : <nl> + - The IP or FQDN address of the NFS server <nl> + type : str <nl> + share : <nl> + description : <nl> + - NFS export on the NFS server <nl> + type : str <nl> + options : <nl> + description : <nl> + - Additonal mount options for the NFS share <nl> + - Supported mount options include I ( port ) , I ( rsize ) , <nl> + I ( wsize ) , I ( nfsvers ) , and I ( tcp ) or I ( udp ) <nl> + required : false <nl> + default : "" "" <nl> + type : str <nl> + access_key : <nl> + description : <nl> + - Access Key ID of the S3 target <nl> + type : str <nl> + bucket : <nl> + description : <nl> + - Name of the bucket for the S3 target <nl> + type : str <nl> + secret : <nl> + description : <nl> + - Secret Access Key for the S3 target <nl> + type : str <nl> + initialize : <nl> + description : <nl> + - Define whether to initialize the S3 bucket <nl> + type : bool <nl> + default : true <nl> + <nl> + extends_documentation_fragment : <nl> + - purestorage . fa <nl> + ' ' ' <nl> + <nl> + EXAMPLES = r ' ' ' <nl> + - name : Create NFS offload target <nl> + purefa_offload : <nl> + name : nfs - offload <nl> + protocol : nfs <nl> + address : 10 . 21 . 200 . 4 <nl> + share : "" / offload_target "" <nl> + fa_url : 10 . 10 . 10 . 2 <nl> + api_token : e31060a7 - 21fc - e277 - 6240 - 25983c6c4592 <nl> + <nl> + - name : Create S3 offload target <nl> + purefa_offload : <nl> + name : s3 - offload <nl> + protocol : s3 <nl> + access_key : "" 3794fb12c6204e19195f "" <nl> + bucket : offload - bucket <nl> + secret : "" wJalrXUtnFEMI / K7MDENG / bPxRfiCYEXAMPLEKEY "" <nl> + fa_url : 10 . 10 . 10 . 2 <nl> + api_token : e31060a7 - 21fc - e277 - 6240 - 25983c6c4592 <nl> + <nl> + - name : Delete offload target <nl> + purefa_offload : <nl> + name : nfs - offload <nl> + protocol : nfs <nl> + state : absent <nl> + fa_url : 10 . 10 . 10 . 2 <nl> + api_token : e31060a7 - 21fc - e277 - 6240 - 25983c6c4592 <nl> + <nl> + <nl> + ' ' ' <nl> + <nl> + RETURN = r ' ' ' <nl> + ' ' ' <nl> + <nl> + import re <nl> + from distutils . version import LooseVersion <nl> + <nl> + from ansible . module_utils . basic import AnsibleModule <nl> + from ansible . module_utils . pure import get_system , purefa_argument_spec <nl> + <nl> + MIN_REQUIRED_API_VERSION = ' 1 . 16 ' <nl> + REGEX_TARGET_NAME = re . compile ( r "" ^ [ a - zA - Z0 - 9 \ - ] * $ "" ) <nl> + <nl> + <nl> + def get_target ( module , array ) : <nl> + "" "" "" Return target or None "" "" "" <nl> + try : <nl> + return array . get_offload ( module . params [ ' name ' ] ) <nl> + except Exception : <nl> + return None <nl> + <nl> + <nl> + def create_offload ( module , array ) : <nl> + "" "" "" Create offload target "" "" "" <nl> + changed = False <nl> + # First check if the offload network inteface is there and enabled <nl> + try : <nl> + if not array . get_network_interface ( ' @ offload . data ' ) [ ' enabled ' ] : <nl> + module . fail_json ( msg = ' Offload Network interface not enabled . Please resolve . ' ) <nl> + except Exception : <nl> + module . fail_json ( msg = ' Offload Network interface not correctly configured . Please resolve . ' ) <nl> + ra_facts = { } <nl> + if module . params [ ' protocol ' ] = = ' nfs ' : <nl> + try : <nl> + array . connect_nfs_offload ( module . params [ ' name ' ] , <nl> + mount_point = module . params [ ' share ' ] , <nl> + address = module . params [ ' address ' ] , <nl> + mount_options = module . params [ ' options ' ] ) <nl> + changed = True <nl> + except Exception : <nl> + module . fail_json ( msg = ' Failed to create NFS offload { 0 } . ' <nl> + ' Please perform diagnostic checks . ' . format ( module . params [ ' name ' ] ) ) <nl> + if module . params [ ' protocol ' ] = = ' s3 ' : <nl> + try : <nl> + array . connect_s3_offload ( module . params [ ' name ' ] , <nl> + access_key_id = module . params [ ' access_key ' ] , <nl> + secret_access_key = module . params [ ' secret ' ] , <nl> + bucket = module . params [ ' bucket ' ] , <nl> + initialize = module . params [ ' initialize ' ] ) <nl> + changed = True <nl> + except Exception : <nl> + module . fail_json ( msg = ' Failed to create S3 offload { 0 } . ' <nl> + ' Please perform diagnostic checks . ' . format ( module . params [ ' name ' ] ) ) <nl> + module . exit_json ( changed = changed , ansible_facts = ra_facts ) <nl> + <nl> + <nl> + def update_offload ( module , array ) : <nl> + "" "" "" Update offload target "" "" "" <nl> + changed = False <nl> + module . exit_json ( changed = changed ) <nl> + <nl> + <nl> + def delete_offload ( module , array ) : <nl> + "" "" "" Delete offload target "" "" "" <nl> + changed = False <nl> + if module . params [ ' protocol ' ] = = ' nfs ' : <nl> + try : <nl> + array . disconnect_nfs_offload ( module . params [ ' name ' ] ) <nl> + changed = True <nl> + except Exception : <nl> + module . fail_json ( msg = ' Failed to delete NFS offload { 0 } . ' . format ( module . params [ ' name ' ] ) ) <nl> + if module . params [ ' protocol ' ] = = ' s3 ' : <nl> + try : <nl> + array . disconnect_nfs_offload ( module . params [ ' name ' ] ) <nl> + changed = True <nl> + except Exception : <nl> + module . fail_json ( msg = ' Failed to delete S3 offload { 0 } . ' . format ( module . params [ ' name ' ] ) ) <nl> + module . exit_json ( changed = changed ) <nl> + <nl> + <nl> + def main ( ) : <nl> + argument_spec = purefa_argument_spec ( ) <nl> + argument_spec . update ( dict ( <nl> + state = dict ( type = ' str ' , default = ' present ' , choices = [ ' present ' , ' absent ' ] ) , <nl> + protocol = dict ( type = ' str ' , default = ' nfs ' , choices = [ ' nfs ' , ' s3 ' ] ) , <nl> + name = dict ( type = ' str ' , required = True ) , <nl> + initialize = dict ( default = True , type = ' bool ' ) , <nl> + access_key = dict ( type = ' str ' ) , <nl> + secret = dict ( type = ' str ' , no_log = True ) , <nl> + bucket = dict ( type = ' str ' ) , <nl> + share = dict ( type = ' str ' ) , <nl> + address = dict ( type = ' str ' ) , <nl> + options = dict ( type = ' str ' , default = ' ' ) , <nl> + ) ) <nl> + <nl> + required_if = [ ] <nl> + <nl> + if argument_spec [ ' state ' ] = = "" present "" : <nl> + required_if = [ <nl> + ( ' protocol ' , ' nfs ' , [ ' address ' , ' share ' ] ) , <nl> + ( ' protocol ' , ' s3 ' , [ ' access_key ' , ' secret ' , ' bucket ' ] ) <nl> + ] <nl> + <nl> + module = AnsibleModule ( argument_spec , <nl> + required_if = required_if , <nl> + supports_check_mode = False ) <nl> + <nl> + array = get_system ( module ) <nl> + api_version = array . _list_available_rest_versions ( ) <nl> + <nl> + if MIN_REQUIRED_API_VERSION not in api_version : <nl> + module . fail_json ( msg = ' FlashArray REST version not supported . ' <nl> + ' Minimum version required : { 0 } ' . format ( MIN_REQUIRED_API_VERSION ) ) <nl> + <nl> + if not re . match ( r "" ^ [ a - zA - Z ] [ a - zA - Z0 - 9 \ - ] * [ a - zA - Z0 - 9 ] $ "" , module . params [ ' name ' ] ) or len ( module . params [ ' name ' ] ) > 56 : <nl> + module . fail_json ( msg = ' Target name invalid . ' <nl> + ' Target name must be between 1 and 56 characters ( alphanumeric and - ) in length ' <nl> + ' and begin and end with a letter or number . The name must include at least one letter . ' ) <nl> + if module . params [ ' protocol ' ] = = "" s3 "" : <nl> + if not re . match ( r "" ^ [ a - z0 - 9 ] [ a - z0 - 9 . \ - ] * [ a - z0 - 9 ] $ "" , module . params [ ' bucket ' ] ) or len ( module . params [ ' bucket ' ] ) > 63 : <nl> + module . fail_json ( msg = ' Bucket name invalid . ' <nl> + ' Bucket name must be between 3 and 63 characters ' <nl> + ' ( ilowercase , alphanumeric , dash or period ) in length ' <nl> + ' and begin and end with a letter or number . ' ) <nl> + <nl> + apps = array . list_apps ( ) <nl> + app_version = 0 <nl> + all_good = False <nl> + for app in range ( 0 , len ( apps ) ) : <nl> + if apps [ app ] [ ' name ' ] = = ' offload ' : <nl> + if ( apps [ app ] [ ' enabled ' ] and <nl> + apps [ app ] [ ' status ' ] = = ' healthy ' and <nl> + LooseVersion ( apps [ app ] [ ' version ' ] ) > = LooseVersion ( ' 5 . 2 . 0 ' ) ) : <nl> + all_good = True <nl> + app_version = apps [ app ] [ ' version ' ] <nl> + break <nl> + <nl> + if not all_good : <nl> + module . fail_json ( msg = ' Correct Offload app not installed or incorrectly configured ' ) <nl> + else : <nl> + if LooseVersion ( array . get ( ) [ ' version ' ] ) ! = LooseVersion ( app_version ) : <nl> + module . fail_json ( msg = ' Offload app version must match Purity version . Please upgrade . ' ) <nl> + <nl> + target = get_target ( module , array ) <nl> + if module . params [ ' state ' ] = = ' present ' and not target : <nl> + target_count = len ( array . list_offload ( ) ) <nl> + # Currently only 1 offload target is supported <nl> + # TODO : ( SD ) when more targets supported add in REST version check as well <nl> + if target_count ! = 0 : <nl> + module . fail_json ( msg = ' Currently only 1 Offload Target is supported . ' ) <nl> + create_offload ( module , array ) <nl> + elif module . params [ ' state ' ] = = ' present ' and target : <nl> + update_offload ( module , array ) <nl> + elif module . params [ ' state ' ] = = ' absent ' and target : <nl> + delete_offload ( module , array ) <nl> + <nl> + module . exit_json ( changed = False ) <nl> + <nl> + <nl> + if __name__ = = ' __main__ ' : <nl> + main ( ) <nl>",Add Pure Storage FlashArray module to support Offload to NFS and S3 targets ( ),ansible/ansible,58849ac228c1187295fb35d9562b1471c11f1740,2019-03-27T14:56:50Z
"mmm a / rest_framework / serializers . py <nl> ppp b / rest_framework / serializers . py <nl> def __init__ ( self , meta ) : <nl> self . write_only_fields = getattr ( meta , ' write_only_fields ' , ( ) ) <nl> <nl> <nl> + def _get_class_mapping ( mapping , obj ) : <nl> + "" "" "" <nl> + Takes a dictionary with classes as keys , and an object . <nl> + Traverses the object ' s inheritance hierarchy in method <nl> + resolution order , and returns the first matching value <nl> + from the dictionary or None . <nl> + <nl> + "" "" "" <nl> + return next ( <nl> + ( mapping [ cls ] for cls in inspect . getmro ( obj . __class__ ) if cls in mapping ) , <nl> + None <nl> + ) <nl> + <nl> + <nl> class ModelSerializer ( Serializer ) : <nl> "" "" "" <nl> A serializer that deals with model instances and querysets . <nl> def get_field ( self , model_field ) : <nl> models . URLField : [ ' max_length ' ] , <nl> } <nl> <nl> - if model_field . __class__ in attribute_dict : <nl> - attributes = attribute_dict [ model_field . __class__ ] <nl> + attributes = _get_class_mapping ( attribute_dict , model_field ) <nl> + if attributes : <nl> for attribute in attributes : <nl> kwargs . update ( { attribute : getattr ( model_field , attribute ) } ) <nl> <nl> - try : <nl> - return self . field_mapping [ model_field . __class__ ] ( * * kwargs ) <nl> - except KeyError : <nl> - return ModelField ( model_field = model_field , * * kwargs ) <nl> + serializer_field_class = _get_class_mapping ( <nl> + self . field_mapping , model_field ) <nl> + <nl> + if serializer_field_class : <nl> + return serializer_field_class ( * * kwargs ) <nl> + return ModelField ( model_field = model_field , * * kwargs ) <nl> <nl> def get_validation_exclusions ( self , instance = None ) : <nl> "" "" "" <nl>",Merge pull request from tituomin / serializer - subclass - mapping,encode/django-rest-framework,e8fac28d8848dce62a31879e07300842bd1755bd,2014-09-06T06:20:31Z
"mmm a / Lib / test / test_getargs2 . py <nl> ppp b / Lib / test / test_getargs2 . py <nl> def test_n ( self ) : <nl> from _testcapi import getargs_n <nl> # n returns ' Py_ssize_t ' , and does range checking <nl> # ( PY_SSIZE_T_MIN . . . PY_SSIZE_T_MAX ) <nl> - self . failUnlessEqual ( 3 , getargs_n ( 3 . 14 ) ) <nl> + self . assertRaises ( TypeError , getargs_n , 3 . 14 ) <nl> self . failUnlessEqual ( 99 , getargs_n ( Long ( ) ) ) <nl> self . failUnlessEqual ( 99 , getargs_n ( Int ( ) ) ) <nl> <nl>",Fix newly merged test for p3ykness .,python/cpython,d8073285ffd92eefee1546d2bbe7156eb957e5d7,2006-04-21T11:36:13Z
"mmm a / Misc / python - mode . el <nl> ppp b / Misc / python - mode . el <nl> A ` nomenclature ' is a fancy way of saying AWordWithMixedCaseNotUnderscores . "" <nl> ( list <nl> ( read - shell - command "" Run pychecker like this : "" <nl> default <nl> - py - pychecker - history ) ) ) ) <nl> + ' py - pychecker - history ) ) ) ) <nl> ( save - some - buffers ( not py - ask - about - save ) nil ) <nl> - ( compile command ) ) <nl> + ( compile - internal command "" No more errors "" ) ) <nl> <nl> <nl> <nl>",( py - pychecker - run ) : Thomas Heller points out that this function messes,python/cpython,daa192104d2cab44df2603cf8c46446e88a57007,2002-07-16T15:56:28Z
"mmm a / zephyr / static / js / narrow . js <nl> ppp b / zephyr / static / js / narrow . js <nl> exports . describe = function ( operators ) { <nl> switch ( elem [ 0 ] ) { <nl> case ' is ' : <nl> if ( operand = = = ' private - message ' ) <nl> - return ' private messages ' ; <nl> + return ' Narrow to all private messages ' ; <nl> break ; <nl> <nl> case ' stream ' : <nl> - return ' stream ' + operand ; <nl> + return ' Narrow to stream ' + operand ; <nl> <nl> case ' subject ' : <nl> - return ' subject ' + operand ; <nl> + return ' Narrow to subject ' + operand ; <nl> <nl> case ' sender ' : <nl> - return ' sender ' + operand ; <nl> + return ' Narrow to sender ' + operand ; <nl> <nl> case ' pm - with ' : <nl> - return ' private messages with ' + operand ; <nl> + return ' Narrow to private messages with ' + operand ; <nl> <nl> case ' search ' : <nl> - return ' messages containing ' + operand ; <nl> + return ' Narrow to messages containing ' + operand ; <nl> <nl> case ' in ' : <nl> - return ' messages in ' + operand ; <nl> + return ' Narrow to messages in ' + operand ; <nl> } <nl> - return ' ( unknown operator ) ' ; <nl> + return ' Narrow to ( unknown operator ) ' ; <nl> } ) . join ( ' , ' ) ; <nl> } ; <nl> <nl> mmm a / zephyr / static / js / search . js <nl> ppp b / zephyr / static / js / search . js <nl> function render_object_in_parts ( obj ) { <nl> / / way we identify action objects by their labels . Using two spaces <nl> / / after ' Narrow to ' ensures this , and is invisible with standard HTML <nl> / / whitespace handling . <nl> - return { prefix : ' Narrow to ' , <nl> + return { prefix : ' ' , <nl> query : narrow . describe ( obj . operators ) , <nl> suffix : ' ' } ; <nl> } <nl>",Move ' Narrow to ' to text inside narrow . describe ( ) .,zulip/zulip,ee3662d1dac5575f4d5c05039f53571958e50ee5,2013-03-05T14:32:59Z
"mmm a / mitmproxy / connections . py <nl> ppp b / mitmproxy / connections . py <nl> <nl> import time <nl> <nl> - import copy <nl> import os <nl> <nl> from mitmproxy import stateobject <nl> def tls_established ( self ) : <nl> tls_version = str , <nl> ) <nl> <nl> - def copy ( self ) : <nl> - return copy . copy ( self ) <nl> - <nl> def send ( self , message ) : <nl> if isinstance ( message , list ) : <nl> message = b ' ' . join ( message ) <nl> def make_dummy ( cls , address ) : <nl> via = None <nl> ) ) <nl> <nl> - def copy ( self ) : <nl> - return copy . copy ( self ) <nl> - <nl> def connect ( self ) : <nl> self . timestamp_start = time . time ( ) <nl> tcp . TCPClient . connect ( self ) <nl> mmm a / mitmproxy / flow . py <nl> ppp b / mitmproxy / flow . py <nl> <nl> import time <nl> - import copy <nl> import uuid <nl> <nl> from mitmproxy import controller # noqa <nl> <nl> from mitmproxy import connections <nl> from mitmproxy import version <nl> <nl> - import typing # noqa <nl> + import typing # noqa <nl> <nl> <nl> class Error ( stateobject . StateObject ) : <nl> def from_state ( cls , state ) : <nl> f . set_state ( state ) <nl> return f <nl> <nl> - def copy ( self ) : <nl> - c = copy . copy ( self ) <nl> - return c <nl> - <nl> <nl> class Flow ( stateobject . StateObject ) : <nl> <nl> def from_state ( cls , state ) : <nl> return f <nl> <nl> def copy ( self ) : <nl> - f = copy . copy ( self ) <nl> - <nl> + f = super ( ) . copy ( ) <nl> f . id = str ( uuid . uuid4 ( ) ) <nl> f . live = False <nl> - f . client_conn = self . client_conn . copy ( ) <nl> - f . server_conn = self . server_conn . copy ( ) <nl> - f . metadata = self . metadata . copy ( ) <nl> - <nl> - if self . error : <nl> - f . error = self . error . copy ( ) <nl> return f <nl> <nl> def modified ( self ) : <nl>",simplify state copy,mitmproxy/mitmproxy,d6d1ff017078ceb1730da9d2138b3ebcdccb7972,2017-02-09T15:08:24Z
"mmm a / library / system / setup <nl> ppp b / library / system / setup <nl> class LinuxHardware ( Hardware ) : <nl> if line . startswith ( ' / ' ) : <nl> fields = line . rstrip ( ' \ n ' ) . split ( ) <nl> if ( fields [ 2 ] ! = ' none ' ) : <nl> + size_total = None <nl> + size_available = None <nl> try : <nl> statvfs_result = os . statvfs ( fields [ 1 ] ) <nl> - self . facts [ ' mounts ' ] . append ( <nl> - { ' mount ' : fields [ 1 ] , <nl> - ' device ' : fields [ 0 ] , <nl> - ' fstype ' : fields [ 2 ] , <nl> - ' options ' : fields [ 3 ] , <nl> - # statvfs data <nl> - ' size_total ' : statvfs_result . f_bsize * statvfs_result . f_blocks , <nl> - ' size_available ' : statvfs_result . f_bsize * ( statvfs_result . f_bavail ) , <nl> - } ) <nl> + size_total = statvfs_result . f_bsize * statvfs_result . f_blocks <nl> + size_available = statvfs_result . f_bsize * ( statvfs_result . f_bavail ) <nl> except OSError , e : <nl> - # don ' t have access to stat so we ' ll set to None <nl> - self . facts [ ' mounts ' ] . append ( <nl> - { ' mount ' : fields [ 1 ] , <nl> - ' device ' : fields [ 0 ] , <nl> - ' fstype ' : fields [ 2 ] , <nl> - ' options ' : fields [ 3 ] , <nl> - # statvfs data <nl> - ' size_total ' : None , <nl> - ' size_available ' : None , <nl> - } ) <nl> + if e . errno = = errno . ENOENT : <nl> + pass <nl> + else : <nl> + self . fail_json ( msg = e . strerror ) <nl> + <nl> + self . facts [ ' mounts ' ] . append ( <nl> + { ' mount ' : fields [ 1 ] , <nl> + ' device ' : fields [ 0 ] , <nl> + ' fstype ' : fields [ 2 ] , <nl> + ' options ' : fields [ 3 ] , <nl> + # statvfs data <nl> + ' size_total ' : size_total , <nl> + ' size_available ' : size_available , <nl> + } ) <nl> <nl> def get_device_facts ( self ) : <nl> self . facts [ ' devices ' ] = { } <nl>",narrowed down exception we ignore and fail if any other unexpected one,ansible/ansible,b7b1c714f90b61d6d3519c34f00970d9358890aa,2013-07-20T15:51:52Z
"mmm a / src / _macosx . m <nl> ppp b / src / _macosx . m <nl> <nl> # include "" numpy / arrayobject . h "" <nl> # include "" path_cleanup . h "" <nl> <nl> + # if PY_MAJOR_VERSION > = 3 <nl> + # define PY3K 1 <nl> + # else <nl> + # define PY3K 0 <nl> + # endif <nl> + <nl> / * Must define Py_TYPE for Python 2 . 5 or older * / <nl> # ifndef Py_TYPE <nl> # define Py_TYPE ( o ) ( ( o ) - > ob_type ) <nl> static int _get_snap ( GraphicsContext * self , enum e_snap_mode * mode ) <nl> static PyObject * <nl> GraphicsContext_repr ( GraphicsContext * self ) <nl> { <nl> - # if PY_MAJOR_VERSION > = 3 <nl> + # if PY3K <nl> return PyUnicode_FromFormat ( "" GraphicsContext object % p wrapping the Quartz 2D graphics context % p "" , ( void * ) self , ( void * ) ( self - > cr ) ) ; <nl> # else <nl> return PyString_FromFormat ( "" GraphicsContext object % p wrapping the Quartz 2D graphics context % p "" , ( void * ) self , ( void * ) ( self - > cr ) ) ; <nl> static int _get_snap ( GraphicsContext * self , enum e_snap_mode * mode ) <nl> <nl> if ( offset ! = Py_None ) <nl> { <nl> - if ( PyFloat_Check ( offset ) ) phase = PyFloat_AsDouble ( offset ) ; <nl> - else if ( PyInt_Check ( offset ) ) phase = PyInt_AsLong ( offset ) ; <nl> + if ( PyFloat_Check ( offset ) ) phase = PyFloat_AS_DOUBLE ( offset ) ; <nl> + # if PY3K <nl> + else if ( PyLong_Check ( offset ) ) phase = PyLong_AS_LONG ( offset ) ; <nl> + # else <nl> + else if ( PyInt_Check ( offset ) ) phase = PyInt_AS_LONG ( offset ) ; <nl> + # endif <nl> else <nl> { <nl> PyErr_SetString ( PyExc_TypeError , <nl> static int _get_snap ( GraphicsContext * self , enum e_snap_mode * mode ) <nl> PyObject * value = PyTuple_GET_ITEM ( dashes , i ) ; <nl> if ( PyFloat_Check ( value ) ) <nl> lengths [ i ] = ( CGFloat ) PyFloat_AS_DOUBLE ( value ) ; <nl> + # if PY3K <nl> + else if ( PyLong_Check ( value ) ) <nl> + lengths [ i ] = ( CGFloat ) PyLong_AS_LONG ( value ) ; <nl> + # else <nl> else if ( PyInt_Check ( value ) ) <nl> lengths [ i ] = ( CGFloat ) PyInt_AS_LONG ( value ) ; <nl> + # endif <nl> else break ; <nl> } <nl> Py_DECREF ( dashes ) ; <nl> static CGRect _find_enclosing_rect ( CGPoint points [ 3 ] ) <nl> # else <nl> ATSFontRef font = 0 ; <nl> # endif <nl> - # if PY_MAJOR_VERSION > = 3 <nl> + # if PY3K <nl> PyObject * ascii = NULL ; <nl> # endif <nl> <nl> static CGRect _find_enclosing_rect ( CGPoint points [ 3 ] ) <nl> for ( i = 0 ; i < n ; i + + ) <nl> { <nl> PyObject * item = PyList_GET_ITEM ( family , i ) ; <nl> - # if PY_MAJOR_VERSION > = 3 <nl> + # if PY3K <nl> ascii = PyUnicode_AsASCIIString ( item ) ; <nl> if ( ! ascii ) return 0 ; <nl> temp = PyBytes_AS_STRING ( ascii ) ; <nl> static CGRect _find_enclosing_rect ( CGPoint points [ 3 ] ) <nl> name = temp ; <nl> break ; <nl> } <nl> - # if PY_MAJOR_VERSION > = 3 <nl> + # if PY3K <nl> Py_DECREF ( ascii ) ; <nl> ascii = NULL ; <nl> # endif <nl> static CGRect _find_enclosing_rect ( CGPoint points [ 3 ] ) <nl> # ifndef COMPILING_FOR_10_5 <nl> CGContextSelectFont ( cr , name , size , kCGEncodingMacRoman ) ; <nl> # endif <nl> - # if PY_MAJOR_VERSION > = 3 <nl> + # if PY3K <nl> Py_XDECREF ( ascii ) ; <nl> # endif <nl> return font ; <nl> static void _data_provider_release ( void * info , const void * data , size_t size ) <nl> CGDataProviderRef provider ; <nl> double rect [ 4 ] = { 0 . 0 , 0 . 0 , self - > size . width , self - > size . height } ; <nl> <nl> - # if PY_MAJOR_VERSION > = 3 <nl> if ( ! PyBytes_Check ( image ) ) <nl> { <nl> - PyErr_SetString ( PyExc_RuntimeError , "" image is not a byte array "" ) ; <nl> - return NULL ; <nl> - } <nl> + # if PY3K <nl> + PyErr_SetString ( PyExc_RuntimeError , "" image is not a bytes object "" ) ; <nl> # else <nl> - if ( ! PyString_Check ( image ) ) <nl> - { <nl> - PyErr_SetString ( PyExc_RuntimeError , "" image is not a string "" ) ; <nl> + PyErr_SetString ( PyExc_RuntimeError , "" image is not a str object "" ) ; <nl> + # endif <nl> return NULL ; <nl> } <nl> - # endif <nl> <nl> const size_t bytesPerComponent = 1 ; <nl> const size_t bitsPerComponent = 8 * bytesPerComponent ; <nl> static void _data_provider_release ( void * info , const void * data , size_t size ) <nl> } <nl> <nl> Py_INCREF ( image ) ; <nl> - # if PY_MAJOR_VERSION > = 3 <nl> - n = PyByteArray_GET_SIZE ( image ) ; <nl> - data = PyByteArray_AS_STRING ( image ) ; <nl> + # ifdef PY3K <nl> + n = PyBytes_GET_SIZE ( image ) ; <nl> + data = PyBytes_AS_STRING ( image ) ; <nl> # else <nl> n = PyString_GET_SIZE ( image ) ; <nl> - data = PyString_AsString ( image ) ; <nl> + data = PyString_AS_STRING ( image ) ; <nl> # endif <nl> <nl> provider = CGDataProviderCreateWithData ( image , <nl> static void _data_provider_release ( void * info , const void * data , size_t size ) <nl> provider , <nl> NULL , <nl> false , <nl> - kCGRenderingIntentDefault ) ; <nl> + kCGRenderingIntentDefault ) ; <nl> CGColorSpaceRelease ( colorspace ) ; <nl> CGDataProviderRelease ( provider ) ; <nl> <nl> static void _data_provider_release ( void * info , const void * data , size_t size ) <nl> static PyObject * <nl> FigureCanvas_repr ( FigureCanvas * self ) <nl> { <nl> - # if PY_MAJOR_VERSION > = 3 <nl> + # if PY3K <nl> return PyUnicode_FromFormat ( "" FigureCanvas object % p wrapping NSView % p "" , <nl> ( void * ) self , ( void * ) ( self - > view ) ) ; <nl> # else <nl> static void _data_provider_release ( void * info , const void * data , size_t size ) <nl> static PyObject * <nl> FigureManager_repr ( FigureManager * self ) <nl> { <nl> - # if PY_MAJOR_VERSION > = 3 <nl> + # if PY3K <nl> return PyUnicode_FromFormat ( "" FigureManager object % p wrapping NSWindow % p "" , <nl> ( void * ) self , ( void * ) ( self - > window ) ) ; <nl> # else <nl> - ( void ) save_figure : ( id ) sender <nl> static PyObject * <nl> NavigationToolbar_repr ( NavigationToolbar * self ) <nl> { <nl> - # if PY_MAJOR_VERSION > = 3 <nl> + # if PY3K <nl> return PyUnicode_FromFormat ( "" NavigationToolbar object % p "" , ( void * ) self ) ; <nl> # else <nl> return PyString_FromFormat ( "" NavigationToolbar object % p "" , ( void * ) self ) ; <nl> - ( void ) save_figure : ( id ) sender <nl> { <nl> if ( states [ i ] = = 1 ) <nl> { <nl> - # if PY_MAJOR_VERSION > = 3 <nl> + # if PY3K <nl> PyList_SET_ITEM ( list , j , PyLong_FromLong ( i ) ) ; <nl> # else <nl> PyList_SET_ITEM ( list , j , PyInt_FromLong ( i ) ) ; <nl> - ( void ) save_figure : ( id ) sender <nl> static PyObject * <nl> NavigationToolbar2_repr ( NavigationToolbar2 * self ) <nl> { <nl> - # if PY_MAJOR_VERSION > = 3 <nl> + # if PY3K <nl> return PyUnicode_FromFormat ( "" NavigationToolbar2 object % p "" , ( void * ) self ) ; <nl> # else <nl> return PyString_FromFormat ( "" NavigationToolbar2 object % p "" , ( void * ) self ) ; <nl> - ( void ) save_figure : ( id ) sender <nl> { <nl> const char * message ; <nl> <nl> + # if PY3K <nl> + if ( ! PyArg_ParseTuple ( args , "" y "" , & message ) ) return NULL ; <nl> + # else <nl> if ( ! PyArg_ParseTuple ( args , "" s "" , & message ) ) return NULL ; <nl> + # endif <nl> + <nl> NSText * messagebox = self - > messagebox ; <nl> <nl> if ( messagebox ) <nl> - ( void ) mouseDown : ( NSEvent * ) event <nl> { <nl> int x , y ; <nl> int num ; <nl> + int dblclick = 0 ; <nl> PyObject * result ; <nl> PyGILState_STATE gstate ; <nl> NSPoint location = [ event locationInWindow ] ; <nl> - ( void ) mouseDown : ( NSEvent * ) event <nl> case NSRightMouseDown : num = 3 ; break ; <nl> default : return ; / * Unknown mouse event * / <nl> } <nl> + if ( [ event clickCount ] = = 2 ) { <nl> + dblclick = 1 ; <nl> + } <nl> gstate = PyGILState_Ensure ( ) ; <nl> - result = PyObject_CallMethod ( canvas , "" button_press_event "" , "" iii "" , x , y , num ) ; <nl> + result = PyObject_CallMethod ( canvas , "" button_press_event "" , "" iiii "" , x , y , num , dblclick ) ; <nl> if ( result ) <nl> Py_DECREF ( result ) ; <nl> else <nl> - ( void ) rightMouseDown : ( NSEvent * ) event <nl> { <nl> int x , y ; <nl> int num = 3 ; <nl> + int dblclick = 0 ; <nl> PyObject * result ; <nl> PyGILState_STATE gstate ; <nl> NSPoint location = [ event locationInWindow ] ; <nl> - ( void ) rightMouseDown : ( NSEvent * ) event <nl> x = location . x ; <nl> y = location . y ; <nl> gstate = PyGILState_Ensure ( ) ; <nl> - result = PyObject_CallMethod ( canvas , "" button_press_event "" , "" iii "" , x , y , num ) ; <nl> + if ( [ event clickCount ] = = 2 ) { <nl> + dblclick = 1 ; <nl> + } <nl> + result = PyObject_CallMethod ( canvas , "" button_press_event "" , "" iiii "" , x , y , num , dblclick ) ; <nl> if ( result ) <nl> Py_DECREF ( result ) ; <nl> else <nl> - ( void ) otherMouseDown : ( NSEvent * ) event <nl> { <nl> int x , y ; <nl> int num = 2 ; <nl> + int dblclick = 0 ; <nl> PyObject * result ; <nl> PyGILState_STATE gstate ; <nl> NSPoint location = [ event locationInWindow ] ; <nl> - ( void ) otherMouseDown : ( NSEvent * ) event <nl> x = location . x ; <nl> y = location . y ; <nl> gstate = PyGILState_Ensure ( ) ; <nl> - result = PyObject_CallMethod ( canvas , "" button_press_event "" , "" iii "" , x , y , num ) ; <nl> + if ( [ event clickCount ] = = 2 ) { <nl> + dblclick = 1 ; <nl> + } <nl> + result = PyObject_CallMethod ( canvas , "" button_press_event "" , "" iiii "" , x , y , num , dblclick ) ; <nl> if ( result ) <nl> Py_DECREF ( result ) ; <nl> else <nl> - ( int ) index <nl> static PyObject * <nl> show ( PyObject * self ) <nl> { <nl> - if ( nwin > 0 ) [ NSApp run ] ; <nl> + if ( nwin > 0 ) <nl> + { <nl> + [ NSApp activateIgnoringOtherApps : YES ] ; <nl> + [ NSApp run ] ; <nl> + } <nl> Py_INCREF ( Py_None ) ; <nl> return Py_None ; <nl> } <nl> - ( int ) index <nl> static PyObject * <nl> Timer_repr ( Timer * self ) <nl> { <nl> - # if PY_MAJOR_VERSION > = 3 <nl> + # if PY3K <nl> return PyUnicode_FromFormat ( "" Timer object % p wrapping CFRunLoopTimerRef % p "" , <nl> ( void * ) self , ( void * ) ( self - > timer ) ) ; <nl> # else <nl> static void timer_callback ( CFRunLoopTimerRef timer , void * info ) <nl> { NULL , NULL , 0 , NULL } / * sentinel * / <nl> } ; <nl> <nl> - # if PY_MAJOR_VERSION > = 3 <nl> + # if PY3K <nl> <nl> static struct PyModuleDef moduledef = { <nl> PyModuleDef_HEAD_INIT , <nl> void init_macosx ( void ) <nl> | | PyType_Ready ( & NavigationToolbarType ) < 0 <nl> | | PyType_Ready ( & NavigationToolbar2Type ) < 0 <nl> | | PyType_Ready ( & TimerType ) < 0 ) <nl> - # if PY_MAJOR_VERSION > = 3 <nl> + # if PY3K <nl> return NULL ; <nl> # else <nl> return ; <nl> # endif <nl> <nl> - # if PY_MAJOR_VERSION > = 3 <nl> + # if PY3K <nl> module = PyModule_Create ( & moduledef ) ; <nl> if ( module = = NULL ) return NULL ; <nl> # else <nl> void init_macosx ( void ) <nl> PyModule_AddObject ( module , "" Timer "" , ( PyObject * ) & TimerType ) ; <nl> <nl> PyOS_InputHook = wait_for_stdin ; <nl> + <nl> + # if PY3K <nl> + return module ; <nl> + # endif <nl> } <nl>",added Michiel ' s macosx patch,matplotlib/matplotlib,7bf6a11754a5922784b8b55f63372c9e7cc1daf7,2012-03-05T14:43:08Z
